/*******************************************************************************
 * Copyright (c) 2020 DisCo Group - Universidad de Zaragoza.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 1.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-1.0/
 *
 * SPDX-License-Identifier: EPL-1.0
 *
 * Contributors:
 *     Abel Gómez
 *     Ignacio Requeno
 *     Diego Pérez
 *******************************************************************************/
import es.unizar.disco.pnml.utils.PnmlDiceUtils;

import helpers;

modeltype UML uses 'http://www.eclipse.org/uml2/5.0.0/UML';
modeltype PNML uses 'http:///ptnet.ecore';
modeltype TYPES uses 'http://es.unizar.disco/simulation/datatypes/1.0';
modeltype TRACE uses 'http://es.unizar.disco/simulation/traces/1.0';
modeltype CONST uses 'http://es.unizar.disco/pnconstants/1.0';
modeltype ECORE uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype DBET uses 'http://es.unizar.disco.dice/libraries/Basic_Enumeration_Types/1.0';	

transformation ad2pnml(in ad : UML, in vars : TYPES, out res : PNML, out traces : TRACE); 

/**
	Main method:
		1.- Create the root elements (PetriNetDoc, PetriNet, Page)
		2.- Transform ActivityNodes, creating subnets of places and transitions
		3.- Transform ControlFlows, linking the previously created subnets
		4.- Complete transformation with the transformation of the partition and resources
*/
main() {
	// Transform top-level elements
	ad.scenario().map model2doc();
	
	// Transform net contents
	ad.scenario().node[UML::ActivityNode] -> map activityNode2subNet();
	ad.scenario().edge[UML::ControlFlow] -> map controlFlow2arcGlobalField();
	ad.scenario().edge[UML::ControlFlow] -> map controlFlow2tarcAllShuffle();
	ad.scenario().node[UML::FinalNode] -> map finalNode();
	ad.scenario().node[UML::ActivityNode] -> map activityNode2tarcNumTuples();
		
	// Transform deployment
    ad->objectsOfType(ActivityPartition)->flatten()[ActivityPartition] -> map partitions2resources();
	
	// Set time metadata
	if (resolveoneIn(UML::NamedElement::model2net, PNML::PetriNet).toolspecifics->notEmpty()) {
		log("Base time unit is 's'");
		log("Base frequency unit is 'Hz'");
	} else {
		log("Base time unit is 'tick'");
		log("Base frequency unit is 'events per tick'");
	}

}

/**
	Create the PetriNetDoc and the PetriNet
*/
mapping UML::NamedElement::model2doc() : PNML::PetriNetDoc {
	nets := self.map model2net();
}

mapping UML::NamedElement::model2net() : PNML::PetriNet {
	id := createRandomUniqueId();
	var temp_text := id;
	
	if (self.name.oclIsUndefined().not() and
		self.name.equalsIgnoreCase("").not()) {
		temp_text := self.name;
	};
	
	name := object PNML::Name {
		text := temp_text;
	};
	pages := self.map model2page();
}

/**
	Create the page
*/
mapping UML::NamedElement::model2page() : PNML::Page {
	id := createRandomUniqueId();
}

/**
	Sets the metadata for the base time unit on the PNML file
*/
mapping baseTimeUnit(unit : String) {
	var net := resolveoneIn(UML::NamedElement::model2net, PNML::PetriNet);
	net.toolspecifics += baseTimeUnitToolInfo(unit);
}

mapping UML::ActivityPartition::partitions2resources() 
when {
	self.represents.getGaExecHost().oclIsUndefined().not();
}{

	var containedNodes := ad.objectsOfKind(UML::ActivityNode)->select(node : ActivityNode | self->intersection(node.inPartition)->notEmpty());
	assert fatal (containedNodes->size() >= 1 ) with log ("At least a node must be present in partition '" + self.toString() + "'");

	// For each partition, we need to modify the subnet that was previously 
	// generated. We add an intermediate place and a set of arcs connecting
	// to the immediate/timed transitions of the subnet. For instance,
	// [T]-->[P']-->[T']-->[P]
	// is transformed into:
	// [T]-->[P']-->[T']-->[P]
	//  ^            ^
	//  |            |
	//  v            v
	// [Resources-Place]
	
	var poolSize := self.represents.getGaExecHost_resMult();
								
	var place := self.map namedElement2place();
	place.initialMarking := object PNML::PTMarking {
			text := poolSize.value();
	};	
	
	// The direction of the arcs connecting the new place and the transitions
	// of the subnet depends on:
	// 1) The type of transition (timed or immediate).
	// 2) The Activity Node (Spout or Bolt) responsible for generating the transition.
	// 
	// In sum:
	// The arcs go from the timed transition (Spouts/Bolts) to the place 
	// The arcs go from the place to the immediate transitions (Bolts) 
	// The arcs go from the place to the timed transition (Spouts)
	
	containedNodes->forEach(node) {	
		assert warning (node.getStormBolt().oclIsUndefined().not() or
		                node.getStormSpout().oclIsUndefined().not()) with log ("Processing a node '" + node.toString() + "' in partition '" + self.toString() + "'");
		if (node.getStormBolt().oclIsUndefined().not() or 
			node.getStormSpout().oclIsUndefined().not()){
            // Timed transition 
			var list_temp_trans := node.getTimedTrans_Node();
			assert fatal (list_temp_trans->size() >= 1) with log ("Could not find a temporal transition in the node '" + node.toString() + "' in partition '" + self.toString() + "'");
			list_temp_trans->forEach(temp_trans){			
				// Get the immediate transitions: start in the timed transition and go back the PN model until arriving the immediate transitions  
				assert warning (temp_trans.InArcs->size() = 1) with log ("The temporal transition '" + temp_trans.toString()+ "'' must have only one input arc. The number of incomming arcs is " + temp_trans.InArcs->size().toString() + " in partition '" + self.toString() + "'");
				
				/* Intermediate place between the timed transition and the immediate transitions */
				var in_arc := temp_trans.InArcs->asSequence()->first();
				var intermediatePlace := in_arc.source;
				
				/* List of immediate transitions */
				var imm_trans := intermediatePlace.InArcs->asSequence();
				assert warning (imm_trans->size() >= 1 ) with log ("Could not find an immediate transition preceding the timed transition '" + temp_trans.toString() + "'' in the node '" + node.toString() + "' of partition '" + self.toString() + "'");
				if (imm_trans->size() >= 1 ){
					/* For each immediate transition, we create a link to the resource's place */
		            imm_trans->forEach(i_trans){
		            	map arc(place, i_trans.source);
		            };
		            map arc(temp_trans, place);	
				}
            };
		}
		/*else if  (node.getStormSpout().oclIsUndefined().not()) {
			var list_temp_trans := node.getTimedTrans_Node();
			assert fatal (list_temp_trans->size() >= 1) with log ("Could not find a temporal transition in the node '" + node.toString() + "' in partition '" + self.toString() + "'");
			list_temp_trans->forEach(temp_trans){
				var arc_1 := map arc(temp_trans, place);
				var arc_2 := map arc(place, temp_trans);
			}
		}*/
	};
	
	// Add tracing information
	self.represents.map trace(place, "partitions2resources");
}

mapping UML::ActivityNode::activityNode2subNet() disjuncts 
UML::ActivityNode::spoutNode2subNet,
UML::ActivityNode::boltNode2subNet {};

/**
	Transform a generic ActivityNodel into the subnets:
	spout: [place]->[transition]
	bolt: [transition]->[place]->[transition]->
		              <\[place]</
*/
mapping UML::ActivityNode::spoutNode2subNet()
	when { (self.getStormSpout().oclIsUndefined().not()) }{
		var imm_trans := self.map activityNode2immediateTransition();
		var temp_trans := self.map activityNode2timedTransition();
		var place_par := self.map activityNode2placeParallelism();
		var place_working := self.map activityNode2place();

		place_par.initialMarking := object PNML::PTMarking {
			text := self.getStorm_parallelism().value();
		};
				
		var arc_1 := map arc(temp_trans, place_par);
		var arc_2 := map arc(place_par, imm_trans);
		//var arc_2 := map arc(place_par, temp_trans);
		var arc_3 := map arc(imm_trans, place_working);
		var arc_4 := map arc(place_working, temp_trans);
		
		// Add tracing information
		self.map trace(place_working, "spoutNode2subNet");
		self.map trace(place_par, "spoutNode2subNet");
		//self.map trace(temp_trans, "spoutNode2subNet");
		self.map trace(temp_trans, getTransitionStormSpout());
		self.map trace(imm_trans, "spoutNode2subNet");
}

mapping UML::ActivityNode::boltNode2subNet()
	when { (self.getStormBolt().oclIsUndefined().not())} {
		var place_1 := self.map activityNode2place();
		
		// Create the intermediate node and transition
		var place_2 := self.map activityNode2placeParallelism();
		place_2.initialMarking := object PNML::PTMarking {
			text := self.getStorm_parallelism().value();
		};
		
		var transition := self.map activityNode2timedTransition();
				
		var arc_1 := map arc(place_1, transition);
		var arc_2 := map arc(transition, place_2);
		
		// Add tracing information
		self.map trace(place_1, "basicActivityNode2place");
		self.map trace(place_2, "basicActivityNode2placeParallelism");
		self.map trace(transition, "basicActivityNode2timedTransition");
}

/*************************************************/
/**
	Transform a generic NamedElement into a Place 
*/
mapping UML::NamedElement::namedElement2place() : PNML::Place {
		containerPage := resolveoneIn(UML::NamedElement::model2page);
		id := createRandomUniqueId();
		if (self.name.oclIsUndefined().not() and
		 	self.name.equalsIgnoreCase("").not()) {
			name := object PNML::Name {
				text := self.name;
			};
		} else {
			name := object PNML::Name {
				text := id.toString();
			};
		};
}

/**
	Transform a generic ControlFlow into a buffer Place 
*/
mapping UML::ControlFlow::controlFlow2placeBuffer() : PNML::Place {
		containerPage := resolveoneIn(UML::NamedElement::model2page);
		id := createRandomUniqueId();
		if (self.name.oclIsUndefined().not() and
		 	self.name.equalsIgnoreCase("").not()) {
			name := object PNML::Name {
				text := self.name;
			};
		} else {
			name := object PNML::Name {
				text := id.toString();
			};
		};
}

/**
	Transform a generic ControlFlow into a Place 
*/
mapping UML::ControlFlow::controlFlow2place(in number: Integer) : PNML::Place {
		containerPage := resolveoneIn(UML::NamedElement::model2page);
		id := createRandomUniqueId();
		if (self.name.oclIsUndefined().not() and
		 	self.name.equalsIgnoreCase("").not()) {
			name := object PNML::Name {
				text := self.name;
			};
		} else {
			name := object PNML::Name {
				text := id.toString();
			};
		};
}

/**
	Transform a generic ActivityNode into a Place 
*/
mapping UML::ActivityNode::activityNode2place() : PNML::Place 
inherits UML::NamedElement::namedElement2place {
}


mapping UML::ActivityNode::activityNode2placeGlobal() : PNML::Place 
inherits UML::NamedElement::namedElement2place {
			name.text := name.text + "_global";
}

/**
	Transform a generic ActivityNode into a Place controlling the parallelism of the Bolt 
*/
mapping UML::ActivityNode::activityNode2placeParallelism() : PNML::Place 
inherits UML::NamedElement::namedElement2place {
			name.text := name.text + "_parallelism";
}

/**
	Transform a generic ActivityNode into a Place controlling the parallelism of the Bolt 
	for 'global' groupings
*/
mapping UML::ActivityNode::activityNode2placeParallelismGlobal() : PNML::Place 
inherits UML::NamedElement::namedElement2place {
			name.text := name.text + "_parallelism_global";
}
/*************************************************/
/**
	Transform a generic NamedElement into a Transition 
*/
mapping UML::NamedElement::namedElement2transition() : PNML::Transition {
		containerPage := resolveoneIn(UML::NamedElement::model2page);
		id := createRandomUniqueId();
		if (self.name.oclIsUndefined().not() and
		 	self.name.equalsIgnoreCase("").not()) {
			name := object PNML::Name {
				text := self.name;
			};
		} else {
			name := object PNML::Name {
				text := id.toString();
			};
		};
}

/**
	Transform a generic NamedElement into a Transition 
*/

mapping UML::NamedElement::namedElement2immediateTransition() : PNML::Transition
inherits UML::NamedElement::namedElement2transition {
		//name.text := self.name + "_transition";
		name.text := name.text + "_transition";
}

/**
	Transform a generic ActivityNode into a Transition and 
	creates any additional ToolInfo depending on the ActivityNode
	subtype (e.g., OpaqueActions with hostDemand may create 
	exponential transitions) 
*/
mapping UML::ActivityNode::activityNode2timedTransition() : PNML::Transition 
inherits UML::NamedElement::namedElement2transition {
	toolspecifics += self[OpaqueAction].map opaqueActionHostDemand2toolInfo(1);
}

/**
	Transform a generic ActivityNode into a timed Transition.
	Required for 'global' grouping 
*/
mapping UML::ActivityNode::activityNode2timedTransitionGlobal() : PNML::Transition 
inherits UML::NamedElement::namedElement2transition {
	toolspecifics += self[OpaqueAction].map opaqueActionHostDemand2toolInfo(2);
}

/**
	Transform a generic ActivityNode into a Transition 
*/

mapping UML::ActivityNode::activityNode2immediateTransition() : PNML::Transition
inherits UML::NamedElement::namedElement2immediateTransition {
}

/**
	Transform a generic ControlFlow into a Transition 
*/

mapping UML::ControlFlow::controlFlow2immediateTransitionNum(in number: Integer) : PNML::Transition {
		containerPage := resolveoneIn(UML::NamedElement::model2page);
		id := createRandomUniqueId();
		if (self.name.oclIsUndefined().not() and
		 	self.name.equalsIgnoreCase("").not()) {
			name := object PNML::Name {
				text := self.name;
			};
		} else {
			name := object PNML::Name {
				text := id.toString();
			};
		};
}


/**
	Transform a generic ControlFlow into a Transition 
*/

mapping UML::ControlFlow::controlFlow2timedTransition() : PNML::Transition {
		containerPage := resolveoneIn(UML::NamedElement::model2page);
		id := createRandomUniqueId();
		if (self.name.oclIsUndefined().not() and
		 	self.name.equalsIgnoreCase("").not()) {
			name := object PNML::Name {
				text := self.name;
			};
		} else {
			name := object PNML::Name {
				text := id.toString();
			};
		};
}

mapping UML::ControlFlow::controlFlow2timedTransitionNum(in number: Integer, in node: UML::ActivityNode) : PNML::Transition
{
		containerPage := resolveoneIn(UML::NamedElement::model2page);
		id := createRandomUniqueId();
		if (self.name.oclIsUndefined().not() and
		 	self.name.equalsIgnoreCase("").not()) {
			name := object PNML::Name {
				text := self.name;
			};
		} else {
			name := object PNML::Name {
				text := id.toString();
			};
		};
		
		toolspecifics += node[OpaqueAction].map opaqueActionHostDemand2toolInfo(number);
}
	
/***********************************************************************/

/**
	Transforms an OpaqueAction with a hostDemand annotation to a ToolInfo element
*/

mapping UML::OpaqueAction::opaqueActionHostDemand2toolInfo(in index : Integer) : List ( PNML::ToolInfo ) 
when {
		self.getStorm_hostDemand().oclIsUndefined().not();
}{
	var hostDemand := self.getStorm_hostDemand();
	result += expTransitionToolInfo( 1 / hostDemand.value());
	result += infServerTransitionToolInfo();
}

/**
	Creates an Arc from 'src' to 'tgt'
*/
mapping arc(in src : PNML::Node, in tgt : PNML::Node) : PNML::Arc {
	containerPage := resolveoneIn(UML::NamedElement::model2page);
	id := createRandomUniqueId();
	source := src;
	target := tgt;
}


/***********************************************************************/
/**
	Transforms a ControlFlow between two ActivityNodes to different subnets,
	being the most simple an arc between the subnets corresponding to the
	ActivityNodes contected by the ControlFlow 
*/
mapping UML::ControlFlow::controlFlow2arcGlobalField() disjuncts 
UML::ControlFlow::basicControlFlow2arcGlobalField, 
UML::ControlFlow::mergeControlFlow2arcGlobalField,
UML::ControlFlow::joinControlFlow2arcGlobalField {};

/**
	Transforms a ControlFlow between two ActivityNodes.
	The ControlFlow is transformed into an immediate transition connecting to the
	place representing the output buffer of the previous bolt
*/

mapping UML::ControlFlow::basicControlFlow2arcGlobalField() when {
	self.source.oclIsKindOf(ActivityNode) and
	self.target.oclIsKindOf(InitialNode).not() and
	(self.source.getStormSpout().oclIsUndefined().not() or
	 self.source.getStormBolt().oclIsUndefined().not()) and
	self.target.oclIsKindOf(ActivityNode) and
	self.target.oclIsKindOf(ActivityFinalNode).not() and
	self.target.getStormBolt().oclIsUndefined().not()
}{
    var source := self.source;
	var bolt := self.target;
	
	var place_buffer := self.map controlFlow2placeBuffer();
	var list_trans_exec := source.getTimedTrans_Node();
	assert fatal (list_trans_exec->size() >= 1) with log ("Could not find a temporal transition in the node '" + source.toString() + "' in partition '" + self.toString() + "'");
	list_trans_exec->forEach(trans_exec){	
		map arc(trans_exec, place_buffer);
	};
			
	if (self.getStormStreamStep_grouping().=(DBET::StreamPolicy::global) ) {
		/* If all the incomming ControlFlows of the MergeNode have the
		 same global_grouping, then, they will share the same resource */
		self.map global_grouping(bolt);	
	} else if (self.getStormStreamStep_grouping().=(DBET::StreamPolicy::field) ) {
		self.map field_grouping(bolt);
	};
	
	// Add tracing information
	self.map trace(place_buffer, "basicControlFlow2arc");
}

/**
	Transforms a ControlFlow between two generic ActivityNode and a MergeNode.
	The ControlFlow is transformed into a single place, and several immediate
	transitions for each incoming ControlFlow
*/
mapping UML::ControlFlow::mergeControlFlow2arcGlobalField() when {
	self.getStormStreamStep().oclIsUndefined().not() and
	self.target.oclIsKindOf(MergeNode)
}{
	var source := self.source;
	var merge_node := self.target;
	assert fatal (merge_node.outgoing->asOrderedSet()->size() = 1) with log("Merge '" + merge_node.toString() + "' should only have a single outgoing ControlFlow");
	
	//var bolt := merge_node.outgoing.target->asOrderedSet()->first();
	var bolt := merge_node.outgoing->asOrderedSet()->first().target;

	var place_buffer := self.map controlFlow2placeBuffer();
	var list_trans_exec := source.getTimedTrans_Node();
	assert fatal (list_trans_exec->size() >= 1) with log ("Could not find a temporal transition in the node '" + source.toString() + "' in partition '" + self.toString() + "'");
	list_trans_exec->forEach(trans_exec){	
		map arc(trans_exec, place_buffer);
	};
	
	if (self.getStormStreamStep_grouping().=(DBET::StreamPolicy::global) ) {
		/* If all the incomming ControlFlows of the MergeNode have the
		 same global_grouping, then, they will share the same resource */	    
		self.map global_grouping(bolt);	
	} else if (self.getStormStreamStep_grouping().=(DBET::StreamPolicy::field) ) {
		self.map field_grouping(bolt);
	};
	
	// Add tracing information
	self.map trace(place_buffer, "mergeControlFlow2arc");
}

/**
	Transforms a ControlFlow between a generic ActivityNode and a Join.
	The Join has been previously transformed as a single transition.
	We need to create a Place for each incoming ControlFlow to enable the
	synchronization of the different execution flows
*/
mapping UML::ControlFlow::joinControlFlow2arcGlobalField() when {
	self.getStormStreamStep().oclIsUndefined().not() and
	self.target.oclIsKindOf(JoinNode)
}{
	var source := self.source;
	var join_node := self.target;
	assert fatal (join_node.outgoing->asOrderedSet()->size() = 1) with log("Join '" + join_node.toString() + "' should only have a single outgoing ControlFlow");
	
	//var bolt := join_node.outgoing.target->asOrderedSet()->first();
	var bolt := join_node.outgoing->asOrderedSet()->first().target;

	var place_buffer := self.map controlFlow2placeBuffer();
	var list_trans_exec := source.getTimedTrans_Node();
	assert fatal (list_trans_exec->size() >= 1) with log ("Could not find a temporal transition in the node '" + source.toString() + "' in partition '" + self.toString() + "'");
	list_trans_exec->forEach(trans_exec){	
		map arc(trans_exec, place_buffer);
	};

	/* In a JoinNode, the bolt must receive all the tuples synchronously.
	- 'Shuffle' and 'all' groupings guarantee that a bolts' thread receives
	at least a tuple from each source.
	- 'Global' and 'Field' grouping are not compatible with JoinNodes:
	   they do not guarantee that the sources produce tokens for all the
	   bolts' thread.
	 */
	assert warning ((self.getStormStreamStep_grouping()!=(DBET::StreamPolicy::global)) and
				  (self.getStormStreamStep_grouping()!=(DBET::StreamPolicy::field)) )
		with log ("Grouping '" + self.getStormStreamStep_grouping().toString() + "' in '" + self.toString() + "' is not compatible with a UML JoinNode");
	if (self.getStormStreamStep_grouping().=(DBET::StreamPolicy::global) ) {
		//self.map global_grouping_sync(bolt);
	} else if (self.getStormStreamStep_grouping().=(DBET::StreamPolicy::field) ) {
		//self.map field_grouping_sync(bolt, join_node);
	};
	
	// Add tracing information
	self.map trace(place_buffer, "joinControlFlow2arc");
}

/*******************************************************************************
  Final node transformation
*******************************************************************************/

mapping UML::ControlFlow::controlFlow2tarcAllShuffle() disjuncts 
UML::ControlFlow::basicControlFlow2arcAllShuffle, 
UML::ControlFlow::mergeControlFlow2arcAllShuffle,
UML::ControlFlow::joinControlFlow2arcAllShuffle {};

/**
	Transforms a ControlFlow between two ActivityNodes.
	The ControlFlow is transformed into an immediate transition connecting to the
	place representing the output buffer of the previous bolt
*/
mapping UML::ControlFlow::basicControlFlow2arcAllShuffle() when {
	self.source.oclIsKindOf(ActivityNode) and
	self.target.oclIsKindOf(InitialNode).not() and
	(self.source.getStormSpout().oclIsUndefined().not() or
	 self.source.getStormBolt().oclIsUndefined().not()) and
	self.target.oclIsKindOf(ActivityNode) and
	self.target.oclIsKindOf(ActivityFinalNode).not() and
	self.target.getStormBolt().oclIsUndefined().not()
}{
    var source := self.source;
	var bolt := self.target;
	
	var place_buffer := self.resolveoneIn(UML::ControlFlow::controlFlow2placeBuffer);
	
	var list_trans_exec := source.getTimedTrans_Node();
	assert fatal (list_trans_exec->size() >= 1) with log ("Could not find a temporal transition in the node '" + source.toString() + "' in partition '" + self.toString() + "'");
	list_trans_exec->forEach(trans_exec){	
		map arc(trans_exec, place_buffer);
	};
			
	if (self.getStormStreamStep_grouping().=(DBET::StreamPolicy::shuffle) ) {
		self.map shuffle_grouping_async(bolt);
	} else if ((self.getStormStreamStep_grouping().=(DBET::StreamPolicy::all) )) {
		self.map all_grouping_async(bolt, list_trans_exec);
	};
}

/**
	Transforms a ControlFlow between two generic ActivityNode and a MergeNode.
	The ControlFlow is transformed into a single place, and several immediate
	transitions for each incoming ControlFlow
*/
mapping UML::ControlFlow::mergeControlFlow2arcAllShuffle() when {
	self.getStormStreamStep().oclIsUndefined().not() and
	self.target.oclIsKindOf(MergeNode)
}{
	var source := self.source;
	var merge_node := self.target;
	assert fatal (merge_node.outgoing->asOrderedSet()->size() = 1) with log("Merge '" + merge_node.toString() + "' should only have a single outgoing ControlFlow");
	
	//var bolt := merge_node.outgoing.target->asOrderedSet()->first();
	var bolt := merge_node.outgoing->asOrderedSet()->first().target;

	var place_buffer := self.resolveoneIn(UML::ControlFlow::controlFlow2placeBuffer);
	var list_trans_exec := source.getTimedTrans_Node();
	assert fatal (list_trans_exec->size() >= 1) with log ("Could not find a temporal transition in the node '" + source.toString() + "' for the ControlFlow '" + self.toString() + "'");
	list_trans_exec->forEach(trans_exec){	
		map arc(trans_exec, place_buffer);
	};
	
	if (self.getStormStreamStep_grouping().=(DBET::StreamPolicy::shuffle) ) {
		self.map shuffle_grouping_async(bolt);
	} else if ((self.getStormStreamStep_grouping().=(DBET::StreamPolicy::all) )) {
		self.map all_grouping_async(bolt, list_trans_exec);
	};
}

/**
	Transforms a ControlFlow between a generic ActivityNode and a Join.
	The Join has been previously transformed as a single transition.
	We need to create a Place for each incoming ControlFlow to enable the
	synchronization of the different execution flows
*/
mapping UML::ControlFlow::joinControlFlow2arcAllShuffle() when {
	self.getStormStreamStep().oclIsUndefined().not() and
	self.target.oclIsKindOf(JoinNode)
}{
	var source := self.source;
	var join_node := self.target;
	assert fatal (join_node.outgoing->asOrderedSet()->size() = 1) with log("Join '" + join_node.toString() + "' should only have a single outgoing ControlFlow");
	
	//var bolt := join_node.outgoing.target->asOrderedSet()->first();
	var bolt := join_node.outgoing->asOrderedSet()->first().target;	
		
	var place_buffer := self.resolveoneIn(UML::ControlFlow::controlFlow2placeBuffer);
	var list_trans_exec := source.getTimedTrans_Node();
	assert fatal (list_trans_exec->size() >= 1) with log ("Could not find a temporal transition in the node '" + source.toString() + "' for the ControlFlow '" + self.toString() + "'");
	list_trans_exec->forEach(trans_exec){	
		map arc(trans_exec, place_buffer);
	};

	/* In a JoinNode, the bolt must receive all the tuples synchronously.
	- 'Shuffle' and 'all' groupings guarantee that a bolts' thread receives
	at least a tuple from each source.
	- 'Global' and 'Field' grouping are not compatible with JoinNodes:
	   they do not guarantee that the sources produce tokens for all the
	   bolts' thread.
	 */
	if (self.getStormStreamStep_grouping().=(DBET::StreamPolicy::shuffle) ) {
		self.map shuffle_grouping_sync(bolt, join_node);
	} else if ((self.getStormStreamStep_grouping().=(DBET::StreamPolicy::all) )) {
		self.map all_grouping_sync(bolt, list_trans_exec, join_node);
	};
}

/**
	Add 'weight' tokens to the outgoing arc of the timed transition of the Petri net
	associated to the ActivityNode 
*/

mapping UML::ActivityNode::activityNode2tarcNumTuples() when {
	 self.getStormBolt().oclIsUndefined().not()
}{
	var bolt := self;
	var weight := getStormBolt_outTuples(bolt).value();
	var list_trans_exec := bolt.getTimedTrans_Node();
	assert fatal (list_trans_exec->size() >= 1) with log ("Could not find a temporal transition in the node '" + bolt.toString() + "'");
	
	list_trans_exec->forEach(temp_trans){		
		temp_trans.OutArcs->forEach(out_arc){
			var place := out_arc.target.oclAsType(Place);
			/* Update the weight in the arcs that are not pointing to a resources place */
			if (place.initialMarking.oclIsUndefined()){
				if (out_arc.inscription.oclIsUndefined().not()){
					out_arc.inscription.text := (out_arc.inscription.text * weight).round();  
				} else{
					out_arc.inscription := object PNML::PTArcAnnotation {
						text := weight.round();
					};
				};
			}
		}
	};
}

/*******************************************************************************
  Stream grouping transformations
*******************************************************************************/

mapping UML::ControlFlow::shuffle_grouping_async(in bolt : UML::ActivityNode) {
	/* Create a new immediate transition for each incoming StormStream */
	var place_buffer := self.resolveoneIn(UML::ControlFlow::controlFlow2placeBuffer);	
	var place_working_bolt := bolt.resolveoneIn(UML::ActivityNode::activityNode2place);
	var place_parall_bolt := bolt.resolveoneIn(UML::ActivityNode::activityNode2placeParallelism);

	var trans_in_bolt := self.map controlFlow2immediateTransitionNum(1);

	var arc_1 := map arc(place_buffer, trans_in_bolt);
	var arc_2 := map arc(place_parall_bolt,trans_in_bolt);
    var arc_3 := map arc(trans_in_bolt, place_working_bolt);
	
	arc_1.inscription := object PNML::PTArcAnnotation {
		text := getStormBolt_inTuples(self, bolt).value();
	};
	
	self.map trace(trans_in_bolt, "shuffleGrouping");	
}

mapping UML::ControlFlow::shuffle_grouping_sync(in bolt : UML::ActivityNode, in join_node : UML::ActivityNode)  when {
	join_node.oclIsKindOf(JoinNode)
}{	
	/* Create a single common immediate transition for all the incoming StormStreams to the JoinNode */
	var place_buffer := self.resolveoneIn(UML::ControlFlow::controlFlow2placeBuffer);
	var place_working_bolt := bolt.resolveoneIn(UML::ActivityNode::activityNode2place);
	var place_parall_bolt := bolt.resolveoneIn(UML::ActivityNode::activityNode2placeParallelism);
	
	var trans_in_bolt := join_node.resolveoneIn(UML::ActivityNode::activityNode2immediateTransition);
	if (trans_in_bolt.oclIsUndefined()){
		trans_in_bolt := join_node.map activityNode2immediateTransition();
		map arc(place_parall_bolt,trans_in_bolt);
		map arc(trans_in_bolt, place_working_bolt);
				
		// Add tracing information
		self.map trace(trans_in_bolt, "shuffleGrouping");
	};
		
	var arc_1 := map arc(place_buffer, trans_in_bolt);	
	arc_1.inscription := object PNML::PTArcAnnotation {
		text := getStormBolt_inTuples(self, bolt).value();
	};
}

mapping UML::ControlFlow::all_grouping_async(in bolt : UML::ActivityNode, inout list_trans_exec2 : List(PNML::Transition)) {
	/* Create a new immediate transition for each incoming StormStream */
	var place_buffer := self.resolveoneIn(UML::ControlFlow::controlFlow2placeBuffer);
	var place_working_bolt := bolt.resolveoneIn(UML::ActivityNode::activityNode2place);
	var place_parall_bolt := bolt.resolveoneIn(UML::ActivityNode::activityNode2placeParallelism);

	var trans_in_bolt := self.map controlFlow2immediateTransitionNum(1);
	
	var arc_1 := map arc(place_buffer, trans_in_bolt);
	var arc_2 := map arc(place_parall_bolt,trans_in_bolt);
    var arc_3 := map arc(trans_in_bolt, place_working_bolt);
    
	arc_1.inscription := object PNML::PTArcAnnotation {
		text := getStormBolt_inTuples(self, bolt).value();
	};
    	
	var parallelism := bolt.getStormBolt_parallelism().value();
	var arc_list := place_buffer.InArcs->asSequence();
	arc_list->forEach(arc){
	arc.inscription := object PNML::PTArcAnnotation {
			text := parallelism;
		};	
	};
 	
 	// Add tracing information
	self.map trace(trans_in_bolt, "allGrouping");	
}

mapping UML::ControlFlow::all_grouping_sync(in bolt : UML::ActivityNode, inout list_trans_exec : List(PNML::Transition), in join_node : UML::ActivityNode)  when {
	join_node.oclIsKindOf(JoinNode)
}{
	/* Create a single common immediate transition for all the incoming StormStreams to the JoinNode */
	var place_buffer := self.resolveoneIn(UML::ControlFlow::controlFlow2placeBuffer);
	var place_working_bolt := bolt.resolveoneIn(UML::ActivityNode::activityNode2place);
	var place_parall_bolt := bolt.resolveoneIn(UML::ActivityNode::activityNode2placeParallelism);
	
	var trans_in_bolt := join_node.resolveoneIn(UML::ActivityNode::activityNode2immediateTransition);
	if (trans_in_bolt.oclIsUndefined()){
		trans_in_bolt := join_node.map activityNode2immediateTransition();
		map arc(trans_in_bolt, place_working_bolt);
		map arc(place_parall_bolt,trans_in_bolt);
		
		// Add tracing information
		self.map trace(trans_in_bolt, "allGrouping");
	};
		
	var arc_1 := map arc(place_buffer, trans_in_bolt);	
	arc_1.inscription := object PNML::PTArcAnnotation {
		text := getStormBolt_inTuples(self, bolt).value();
	};
		
	var parallelism := bolt.getStormBolt_parallelism().value();
	var arc_list := place_buffer.InArcs->asSequence();
	arc_list->forEach(arc){
	arc.inscription := object PNML::PTArcAnnotation {
			text := parallelism;
		};	
	};
}

mapping UML::ControlFlow::global_grouping(in bolt : UML::ActivityNode) {
	var place_buffer := self.resolveoneIn(UML::ControlFlow::controlFlow2placeBuffer);
	var place_parallel_bolt := bolt.resolveoneIn(UML::ActivityNode::activityNode2placeParallelism);

	/* All StormStreams having the 'Global' grouping share the same bolt thread_id */
	var temp_trans_global := bolt.resolveoneIn(UML::ActivityNode::activityNode2timedTransitionGlobal);
	if (temp_trans_global.oclIsUndefined()){
		temp_trans_global := bolt.map activityNode2timedTransitionGlobal();
		
		var trans_in_bolt := self.map controlFlow2immediateTransitionNum(1);
		var place_work_global := bolt.map activityNode2placeGlobal();
		var place_resource_global := bolt.map activityNode2placeParallelismGlobal();
		place_resource_global.initialMarking := object PNML::PTMarking {
				text := 1;
		};
		
		map arc(trans_in_bolt, place_work_global);
		map arc(place_work_global, temp_trans_global);
		
		map arc(temp_trans_global, place_resource_global);
		map arc(place_resource_global, trans_in_bolt);
		
		map arc(temp_trans_global, place_parallel_bolt);
		map arc(place_parallel_bolt, trans_in_bolt);
			
		// Add tracing information
		self.map trace(trans_in_bolt, "globalGrouping");
		self.map trace(temp_trans_global, "globalGrouping");
		self.map trace(place_work_global, "globalGrouping");
		self.map trace(place_resource_global, "globalGrouping");
	};
	
	var place_resource_global := bolt.resolveoneIn (UML::ActivityNode::activityNode2placeParallelismGlobal);
	var trans_in_bolt := place_resource_global.OutArcs->asSequence()->first().target;
		
	var arc_1 := map arc(place_buffer, trans_in_bolt);
	arc_1.inscription := object PNML::PTArcAnnotation {
		text := getStormBolt_inTuples(self, bolt).value();
	};
}

mapping UML::ControlFlow::field_grouping(in bolt : UML::ActivityNode) {
	var place_buffer := self.resolveoneIn(UML::ControlFlow::controlFlow2placeBuffer);
	var place_parallel_bolt := bolt.resolveoneIn(UML::ActivityNode::activityNode2placeParallelism);
	var temp_trans := bolt.resolveoneIn(UML::ActivityNode::activityNode2timedTransition);
		
	var numFields := self.getStormStreamStep_numFields();
	var probFieldList := self.getStormStreamStep_probFields();
	var numThreads := bolt.getStorm_parallelism();
	var c := 1;

	/* At maximum, there will be as many pipelines as the number of Bolt's threads */
	assert warning (numFields <= numThreads.value()) with log ("There are defined more probFields (" + numFields.toString() + ") than Task's threads (" + numThreads.value().toString() + ")");
	if (numFields > numThreads.value() ){
		numFields := numThreads.value();
		probFieldList := self.normalize(numFields);
	};

	/* The available threads are shared proportionally by each field value */
	var res_per_pipeline := (place_parallel_bolt.initialMarking.text / numFields).floor();
	assert warning (res_per_pipeline > 0) with log ("Not enough resources (" + res_per_pipeline.toString() + ") for all the probFields paths (" + numFields.toString() + ")");
	var weight := getStormBolt_inTuples(self, bolt).value();
	var i := numFields;	
	while (i > 0){
		/* Create a independent processing pipeline for each field value */
		var temp_trans_i := self.map controlFlow2timedTransitionNum(i+1, bolt);
		
		var trans_in_i := self.map controlFlow2immediateTransitionNum(i);
		
		var probField := probFieldList->at(numFields - i + 1);
		trans_in_i.toolspecifics:= probTransitionToolInfo(probField);
		
		var place_work_i := self.map controlFlow2place(c);
		var place_resource_i := self.map controlFlow2place(c+1);
		c := c + 2;
		
		/* The last pipeline uses the remaining threads	and tuples */
		if (i = 1){
			res_per_pipeline := (place_parallel_bolt.initialMarking.text -
								(place_parallel_bolt.initialMarking.text / numFields).floor() * (numFields - 1));
		};
		
		place_resource_i.initialMarking := object PNML::PTMarking {
				text := res_per_pipeline;
		};
		
		var arc_1 := map arc(place_buffer, trans_in_i);
		arc_1.inscription := object PNML::PTArcAnnotation {
			text := weight.toString().toInteger();
		};
		
		map arc(trans_in_i, place_work_i);
		map arc(place_work_i, temp_trans_i);
		
		map arc(temp_trans_i, place_resource_i);
		map arc(place_resource_i, trans_in_i);
		
		map arc(temp_trans_i, place_parallel_bolt);
		map arc(place_parallel_bolt, trans_in_i);
		
		i := i - 1;
		
		// Add tracing information
		self.map trace(trans_in_i, "fieldGrouping");
		self.map trace(temp_trans_i, "fieldGrouping");
		self.map trace(place_work_i, "fieldGrouping");
		self.map trace(place_resource_i, "fieldGrouping");
	};	
}

/*******************************************************************************
  Final node transformation
*******************************************************************************/

mapping UML::FinalNode::finalNode() {
	var source_list := self.incoming->asSequence();
	var source := source_list->first().source;
	assert fatal ((source_list->size() = 1) and 
				   source.oclIsKindOf(ActivityNode) and
				   source.getStormBolt().oclIsUndefined().not())
	with log('Final node should be preceded by a StormBolt');
		
	/* Create a new place and immediate transition.
	TimedTransition -> Place -> ImmTransition */
	var final_trans := self.map activityNode2immediateTransition();
	var place := self.map activityNode2place();
	
	var list_temp_trans := source.getTimedTrans_Node();
	assert fatal (list_temp_trans->size() >= 1) with log ("Could not find a temporal transition in the node '" + source.toString() + "'");
	list_temp_trans->forEach(temp_trans){			
		map arc(temp_trans, place);
	};
	map arc(place, final_trans);

	// Add tracing information
	self.map trace(place, "finalNode");
	self.map trace(final_trans, "finalNode");
}

/*******************************************************************************
  Traceability mappings
*******************************************************************************/

mapping OclAny::trace(to : OclAny) : TRACE::Trace {
	init {
		result := object TRACE::Trace {
			fromDomainElement := self.eObject();
			toAnalyzableElement := to.eObject();
		}
	}
}

mapping OclAny::trace(to : OclAny, text : String) : TRACE::Trace {
	init {
		result := object TRACE::Trace {
			fromDomainElement := self.eObject();
			toAnalyzableElement := to.eObject();
			rule := text;
		}
	}
}

/*******************************************************************************
  Navigation helpers
  Helpers on domains are only valid in the context of a transformations and
  cannot be moved to a library
*******************************************************************************/

helper UML::scenario() : UML::Activity {
	// When running the transformation from the simulation tool, the UML domain must 
	// contain a single activity at its root 
	assert warning (self.rootObjects()[UML::Activity]->size() = 1) with log ("No single Activity instance was found at the root of the UML input model, trying to use the first Activity in the model instead");
	
	if (self.rootObjects()[UML::Activity]->isEmpty().not()) {
		return self.rootObjects()[UML::Activity]->asOrderedSet()->first();
	};
	// This execution path is useful when running the transformation at development time
	return self.objectsOfType(UML::Activity)->asOrderedSet()->first();
}

helper TYPES::vars() : Set ( PrimitiveVariableAssignment ) {
	return self.rootObjects()[PrimitiveVariableAssignment];
}

helper TYPES::PrimitiveVariableAssignment::asDict() : Dict(String, Real) {
	var vars : Dict (String, Real) := Dict {};
	self->forEach(assignment) {
		vars->put(assignment.variable, assignment.value.toString().toReal());
	};
	return vars;
}

helper TRACE::set() : TRACE::TraceSet {
	return self.rootObjects()[TRACE::TraceSet]->asSequence()->first();
}

/*******************************************************************************
  Intermediate classes
  Sadly, intermediate classes cannot be shared among libraries or 
  transformations.
*******************************************************************************/
   
intermediate class NFP_CommonType {
	_rawExpression : String;
	expr : String;
	source : String;
	statQ : String;
	dir : String;
	mode : String;
}

intermediate class NFP_Integer extends NFP_CommonType {
	value : Integer;
}

intermediate class NFP_Real extends NFP_CommonType{
	value : Real;
}

intermediate class NFP_Duration extends NFP_Real {
	unit : String;
	clock : String;
	precision : Real;
	worst : Real;
	best : Real;
}

/*******************************************************************************
  Tagged values utilities
*******************************************************************************/

/**
	Helper that parses a VSL tuple containing a NFP_CommonType
*/
helper String::toNfpCommonType() : NFP_CommonType {
	var res := object NFP_CommonType {
		_rawExpression := self;
		statQ := null;
		expr := null;
		source := null;
		dir := null;
		mode := null;
	};
	if (self.isTuple()) {
		var entries := self.asTuple();
		res.expr := entries->get("expr");
		res.statQ := entries->get("statQ");
		res.source := entries->get("source");
		res.dir := entries->get("dir");
		res.mode := entries->get("mode");
	} else {
		res.expr := self;
	};
	assert warning (res.statQ.oclIsUndefined() or res.statQ = 'mean') 
		with log ("Expression '" + self + "' defines an unknown 'statQ' value, expected empty or 'mean'");
	assert warning (res.source.oclIsUndefined() or res.source = 'est' or res.source = 'meas')
		with log ("Expression '" + self + "' defines an unsupported 'source' for an input parameter, expected 'est' or 'meas'.");
	assert warning (res.dir.oclIsUndefined())
		with log ("Expression '" + self + "' defines a value for the unsupported 'dir' property");
	assert warning (res.mode.oclIsUndefined())
		with log ("Expression '" + self + "' defines a value for the unsupported 'mode' property");
	return res;
}

/**
	Helper that parses a VSL tuple containing a NFP_Integer
*/
helper String::toNfpInteger() : NFP_Integer {
	var nfp := self.toNfpCommonType();
	var res := object NFP_Integer {
		_rawExpression := nfp._rawExpression;
		expr := nfp.expr;
		statQ := nfp.statQ;
		source := nfp.source;
		dir := nfp.dir;
		mode := nfp.mode;
		value := null;
	};
	if (self.isTuple()) {
		var entries := self.asTuple();
		res.value := entries->get("value").toInteger();
	};
	assert fatal (res.value.oclIsUndefined() xor res.expr.oclIsUndefined())
		with log ("Expression '" + self + "' must define either a valid 'value' or a valid 'expr'");
	return res;
}

/**
	Helper that parses a VSL tuple containing a NFP_Real
*/
helper String::toNfpReal() : NFP_Real {
	var nfp := self.toNfpCommonType();
	var res := object NFP_Real {
		_rawExpression := nfp._rawExpression;
		expr := nfp.expr;
		statQ := nfp.statQ;
		source := nfp.source;
		dir := nfp.dir;
		mode := nfp.mode;
		value := null;
	};
	if (self.isTuple()) {
		var entries := self.asTuple();
		res.value := entries->get("value").toReal();
	};
	assert fatal (res.value.oclIsUndefined() xor res.expr.oclIsUndefined())
		with log ("Expression '" + self + "' must define either a valid 'value' or a valid 'expr'");
	return res;
}


/**
	Helper that parses a VSL tuple containing a NFP_Duration
*/
helper String::toNfpDuration() : NFP_Duration {
	var nfp := self.toNfpReal();
	var res := object NFP_Duration {
		_rawExpression := nfp._rawExpression;
		value := nfp.value;
		expr := nfp.expr;
		statQ := nfp.statQ;
		source := nfp.source;
		dir := nfp.dir;
		mode := nfp.mode;
		unit := null;
		clock := null;
		precision := null;
		worst := null;
		best := null;
	};
	if (self.isTuple()) {
		var entries := self.asTuple();
		res.unit := entries->get("unit");
		res.clock := entries->get("clock");
		res.precision := entries->get("precision").toReal();
		res.worst := entries->get("worst").toReal();
		res.best := entries->get("best").toReal();
	};
	assert warning (res.unit.oclIsUndefined().not())
		with log ("Expression '" + self + "' does not define a 'unit', assumming the default base unit (see complete log)");
	assert warning (res.dir.oclIsUndefined())
		with log ("Expression '" + self + "' defines a value for the unsupported 'clock' property");
	assert warning (res.dir.oclIsUndefined())
		with log ("Expression '" + self + "' defines a value for the unsupported 'precision' property");
	assert warning (res.dir.oclIsUndefined())
		with log ("Expression '" + self + "' defines a value for the unsupported 'worst' property");
	assert warning (res.dir.oclIsUndefined())
		with log ("Expression '" + self + "' defines a value for the unsupported 'best' property");
	
	return res;
}

helper NFP_Integer::value() : Integer {
	if (self.value.oclIsUndefined().not()) {
		return self.value;
	};
	return self.expr.eval(vars.vars()).toInteger();
}

helper NFP_Real::value() : Real {
	if (self.value.oclIsUndefined().not()) {
		return self.value;
	};
	return self.expr.eval(vars.vars()).toReal();
}

helper NFP_Duration::value() : Real {
	var value : Real;	
	if (self.value.oclIsUndefined().not()) {
		value := self.value;
	};
	value := self.expr.eval(vars.vars()).toReal();
	if (self.unit.oclIsUndefined().not()) {
		map baseTimeUnit("s");			
		value := value.convert(self.unit, "s");
	};
	return value;
}

/*******************************************************************************
  Getters for tagged values
******************************************************************************/

helper UML::Element::getStorm_hostDemand() : NFP_Duration {
	if (self.getStormBolt().oclIsUndefined().not()){
		return self.getStormBolt_hostDemand();	
	} else if (self.getStormSpout().oclIsUndefined().not()){ 
		return self.getStormSpout_hostDemand();
	} else {
		return null;
	}
}

helper UML::Element::getStormBolt_hostDemand() : NFP_Duration {
	if (self.getStormBolt() = null) {
		return null;
	};
	var hostDemandStrings := self.getValue(self.getStormBolt(), "hostDemand").oclAsType(Collection(String));
	assert warning (hostDemandStrings->size() = 1)
		with log ("Unexpected number of 'hostDemand' tagged values found, expected 1. "+
					"Only the first 'mean' value will be used (if found). " + 
					"The context element is '" + self.toString() + "'"); 
	return hostDemandStrings.toNfpDuration()->
			select(demand | demand.statQ.oclIsUndefined() or demand.statQ = 'mean')->
			asSequence()->first();
}

helper UML::Element::getStormSpout_hostDemand() : NFP_Duration {
	if (self.getStormSpout() = null) {
		return null;
	};
	var hostDemandStrings := self.getValue(self.getStormSpout(), "hostDemand").oclAsType(Collection(String));
	assert warning (hostDemandStrings->size() = 1)
		with log ("Unexpected number of 'hostDemand' tagged values found, expected 1. "+
					"Only the first 'mean' value will be used (if found). " + 
					"The context element is '" + self.toString() + "'"); 
	return hostDemandStrings.toNfpDuration()->
			select(demand | demand.statQ.oclIsUndefined() or demand.statQ = 'mean')->
			asSequence()->first();
}

/******************************************************************/
helper UML::Element::getStorm_parallelism() : NFP_Integer {
	if (self.getStormBolt().oclIsUndefined().not()){
		return self.getStormBolt_parallelism();	
	} else if (self.getStormSpout().oclIsUndefined().not()){ 
		return self.getStormSpout_parallelism();
	} else {
		return null;
	}
}

helper UML::Element::getStormBolt_parallelism() : NFP_Integer {
	if (self.getStormBolt() = null) {
		return null;
	};
	var parallelism := self.getValue(self.getStormBolt(), "parallelism").oclAsType(String);
	assert warning (parallelism->size() = 1)
		with log ("Unexpected number of 'parallelism' tagged values found, expected 1. "+
		 			"parallelism='"+ parallelism.toString() +"' "+
					"The context element is '" + self.toString() + "'"); 
					
	return parallelism.toNfpInteger();
}

helper UML::Element::getStormSpout_parallelism() : NFP_Integer {
	if (self.getStormSpout() = null) {
		return null;
	};
	var parallelism := self.getValue(self.getStormSpout(), "parallelism").oclAsType(String);
	assert warning (parallelism->size() = 1)
		with log ("Unexpected number of 'parallelism' tagged values found, expected 1. "+
					"The context element is '" + self.toString() + "'"); 
					
	return parallelism.toNfpInteger();
}

/******************************************************************/
helper UML::Element::getStormBolt_sigma() : NFP_Real {
	if (self.getStormBolt() = null) {
		return null;
	};
	var sigma := self.getValue(self.getStormBolt(), "sigma").oclAsType(String);
	
	if (sigma = ""){
		return null;
	};
	
	assert warning (sigma->size() = 1)
		with log ("Unexpected number of 'sigma' tagged values found, expected 1. "+
					"The context element is '" + self.toString() + "'"); 
					
	return sigma.toNfpReal();
}

/******************************************************************/
helper UML::Element::getStormBolt_sigma_inTuples() : NFP_Integer {
	if (self.getStormBolt() = null) {
		return null;
	};
	var inTuples := (1.0 / self.getStormBolt_sigma().value().round()).toString(); 
					
	return inTuples.toNfpInteger();
}

helper UML::Element::getStormBolt_sigma_outTuples() : NFP_Integer {
	if (self.getStormBolt() = null) {
		return null;
	};
	var outTuples := self.getStormBolt_sigma().value().round().toString(); 
					
	return outTuples.toNfpInteger();
}

/******************************************************************/
helper getStormBolt_inTuples(in stream : UML::ControlFlow, in bolt : UML::ActivityNode) : NFP_Integer {
	var inTuples := "1";
	
	/**/
	var stream_numTuples := stream.getStormStreamStep_numTuples();
	var bolt_numTuples := bolt.getStormBolt_sigma_inTuples();
	/**/
	if ((stream_numTuples != null) and
		stream_numTuples.oclIsUndefined().not() and
		(stream_numTuples.value() > 0) ) {
		return stream.getStormStreamStep_numTuples();
	} else if ((bolt_numTuples != null) and
				bolt_numTuples.oclIsUndefined().not() and
				(bolt_numTuples.value() > 1) ) {
				return bolt_numTuples;
	};	
	return inTuples.toNfpInteger();
}

helper getStormBolt_inTuples2(in stream : UML::ControlFlow, in bolt : UML::ActivityNode) : NFP_Integer {
	var inTuples := "1";
	
	if (stream.getStormStreamStep() != null) {
		inTuples := stream.getStormStreamStep_numTuples().value().toString();
	} else if (bolt.getStormStreamStep() != null) {
		var real_value := 1.0 / bolt.getStormBolt_sigma().value();
		if (real_value.round() > 1) {
			inTuples := (real_value.round()).toString();
		}
	};	
	return inTuples.toNfpInteger();
}

helper getStormBolt_outTuples_int(in bolt : UML::ActivityNode) : NFP_Integer {
	var outTuples := "1";
	
	if (bolt.getStormBolt_sigma() != null) {
		outTuples := (bolt.getStormBolt_sigma().value().round()).toString();
	};				
	return outTuples.toNfpInteger();
}

helper getStormBolt_outTuples(in bolt : UML::ActivityNode) : NFP_Real {
	var outTuples := "1.0";
	
	if (bolt.getStormBolt_sigma() != null) {
		outTuples := bolt.getStormBolt_sigma().value().toString();
	};
	return outTuples.toNfpReal();
}

/******************************************************************/
helper UML::Element::getStormStreamStep_numTuples() : NFP_Integer {
	if (self.getStormStreamStep() = null) {
		return null;
	};
	var numTuples := self.getValue(self.getStormStreamStep(), "numTuples").oclAsType(String);
	if (numTuples = ""){
		return null;
	};
	
	assert warning (numTuples->size() = 1)
		with log ("Unexpected number of 'numTuples' tagged values found, expected 1. "+
					"The context element is '" + self.toString() + "'"); 
					
	return numTuples.toNfpInteger();
}

/******************************************************************/
helper UML::Element::getStormStreamStep_grouping() : DBET::StreamPolicy {
	if (self.getStormStreamStep() = null) {
		return null;
	};
	var grouping := self.getValue(self.getStormStreamStep(), "grouping").oclAsType(DBET::StreamPolicy);
	assert warning (grouping->size() = 1)
		with log ("Unexpected number of 'grouping' tagged values found, expected 1. "+
					"The context element is '" + self.toString() + "'");
					
	return grouping;
}

/******************************************************************/
helper UML::Element::getStormStreamStep_numFields() : Natural {
	if (self.getStormStreamStep() = null) {
		return null;
	};
	var probFields := self.getValue(self.getStormStreamStep(), "probFields").oclAsType(Collection(String));
	assert warning (probFields->size() >= 1)
		with log ("Unexpected number of 'prob' tagged values found, expected >= 1. "+
					"The context element is '" + self.toString() + "'");

	var probFieldsList := probFields->asSequence();
	var res = new List(NFP_Real)() ;
	probFieldsList->forEach(probF){
		res += probF.toNfpReal();
	};

	return probFields->size();
}

/******************************************************************/
helper UML::Element::getStormStreamStep_probFields() : List(Real) {
	var probFields := self.getValue(self.getStormStreamStep(), "probFields").oclAsType(Collection(String));
	assert warning (probFields->size() >= 1)
		with log ("Unexpected number of 'prob' tagged values found, expected >= 1. "+
					"The context element is '" + self.toString() + "'");
	
	var total_value := 0.0; 
	var probFieldsList := probFields->asSequence();
	var res = new List(Real)() ;
	
	/* Compute the summation of all probabilities */
	probFieldsList->forEach(probF){
		total_value := total_value + probF.toNfpReal().value();
	};

	/* Normalize the probabilities */
	probFieldsList->forEach(probF){
		res += probF.toNfpReal().value()/total_value;
	};
	
	return res;
}

helper UML::Element::normalize(in numElements: Integer) : List(Real) {
	var probFields := self.getValue(self.getStormStreamStep(), "probFields").oclAsType(Collection(String));
	
	var total_value := 0.0; 
	var probFieldsList := probFields->asSequence();
	var res = new List(Real)() ;
	
	/* Compute the summation of all probabilities */
	var i := numElements;
	while (i > 0){
		var probF := probFieldsList->at(i);
		total_value := total_value + probF.toNfpReal().value();
		i := i - 1;
	};

	/* Normalize the probabilities */
	i := numElements;
	while (i > 0){
		var probF := probFieldsList->at(i);
		res += probF.toNfpReal().value()/total_value;
		i := i - 1; 
	};
	
	return res;
}

/******************************************************************/
helper UML::Element::getGaExecHost_resMult() : NFP_Integer {
	if (self.getGaExecHost() = null) {
		return null;
	};
	var prob := self.getValue(self.getGaExecHost(), "resMult").oclAsType(String);
	return prob.toNfpInteger();
}


/******************************************************************/
helper UML::ActivityNode::getTimedTrans_Node() : List(PNML::Transition) {
	var listTimedTrans := new List (PNML::Transition) ();
	var place_parallel_node := self.resolveoneIn(UML::ActivityNode::activityNode2placeParallelism);
	var listInArcs := place_parallel_node.InArcs->asSequence();
	listInArcs->forEach(arc_timed_trans){
		listTimedTrans +=  arc_timed_trans.source.oclAsType(PNML::Transition);
	};
	
	return listTimedTrans;
}

/******************************************************************/
helper UML::ControlFlow::integrity_global_grouping() : Boolean {
	var listInArcs := self.target.incoming;
	var num_global_arcs := 0;
	listInArcs->forEach(arc){
		if (arc.getStormStreamStep_grouping().=(DBET::StreamPolicy::global))
			num_global_arcs := num_global_arcs + 1;
	};
	return (num_global_arcs <= 1);
}
	
helper UML::ActivityNode::integrity_global_grouping() : Boolean {
	if (self.getStormBolt() = null) {
		return null;
	};
	
	var listInArcs := self.incoming;
	var num_global_arcs := 0;
	listInArcs->forEach(arc){
		if (arc.getStormStreamStep_grouping().=(DBET::StreamPolicy::global))
			num_global_arcs := num_global_arcs + 1;
	};
	return (num_global_arcs <= 1);
}
